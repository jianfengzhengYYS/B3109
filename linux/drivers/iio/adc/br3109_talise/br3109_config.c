/**
 * \file br3109_config.c
 * \brief Contains Br3109 configuration settings for the Br3109 API
 *
 * Copyright 2022 briradio..
 * Released under the BR3109 API license, for more information see the "LICENSE.txt" file in this zip file.
 *
 * The top level structure br3109Device_t talDevice uses keyword
 * extern to allow the application layer main() to have visibility
 * to these settings.
 *
 * This file may not be fully complete for the end user application and 
 * may need to updated for AGC, GPIO, and DAC full scale settings. 
 * To create a full initialisation routine, the user should also refer to the 
 * Iron Python initialisation routine generated by the GUI, and also the Br3109 User Guide.
 *
 */
#include "br3109_types.h"
#include "br3109_config.h"
#include "br3109_error.h"
#include "br3109_agc.h"
//#define JESD204B_SPEED_4P9G
#ifdef JESD204B_SPEED_4P9G
int16_t txFirCoefs[40] = {-14, 5, -9, 6, -4, 19, -29, 27, -30, 46, -63, 77, -103, 150, -218, 337, -599, 1266, -2718, 19537, -2718, 1266, -599, 337, -218, 150, -103, 77, -63, 46, -30, 27, -29, 19, -4, 6, -9, 5, -14, 0};

int16_t rxFirCoefs[72] = {0, 0, 2, 0, -7, -1, 15, 4, -31, -10, 57, 23, -99, -47, 161, 86, -247, -146, 372, 238, -542, -381, 762, 583, -1064, -883, 1470, 1331, -2057, -2059, 2975, 3403, -4748, -6898, 9698, 30806, 30806, 9698, -6898, -4748, 3403, 2975, -2059, -2057, 1331, 1470, -883, -1064, 583, 762, -381, -542, 238, 372, -146, -247, 86, 161, -47, -99, 23, 57, -10, -31, 4, 15, -1, -7, 0, 2, 0, 0};

int16_t obsrxFirCoefs[24] = {-10, 7, -10, -12, 6, -12, 16, -16, 1, 63, -431, 17235, -431, 63, 1, -16, 16, -12, 6, -12, -10, 7, -10, 0};
#else
int16_t txFirCoefs[20] = {-39, 24, -62, 112, -175, 298, -574, 1284, -2814, 20281, -2814, 1284, -574, 298, -175, 112, -62, 24, -39, 0};

int16_t rxFirCoefs[48] = {-2, 23, 46, -17, -104, 10, 208, 23, -370, -97, 607, 240, -942, -489, 1407, 910, -2065, -1637, 3058, 2995, -4912, -6526, 9941, 30489, 30489, 9941, -6526, -4912, 2995, 3058, -1637, -2065, 910, 1407, -489, -942, 240, 607, -97, -370, 23, 208, 10, -104, -17, 46, 23, -2};

int16_t obsrxFirCoefs[24] = {-15, 9, -13, 19, -28, 38, -73, 110, -195, 409, -1006, 17711, -1006, 409, -195, 110, -73, 38, -28, 19, -13, 9, -15, 0};
#endif

br3109Init_t talInit =
{
	/* SPI settings */
    .spiSettings =
    {
		.MSBFirst            = 1,  /* 1 = MSBFirst, 0 = LSBFirst */
		.enSpiStreaming      = 0,  /* Not implemented in ADIs platform layer. SW feature to improve SPI throughput */
		.autoIncAddrUp       = 1,  /* Not implemented in ADIs platform layer. For SPI Streaming, set address increment direction. 1= next addr = addr+1, 0:addr=addr-1 */
		.fourWireMode        = 1,  /* 1: Use 4-wire SPI, 0: 3-wire SPI (SDIO pin is bidirectional). NOTE: ADI's FPGA platform always uses 4-wire mode */
		.cmosPadDrvStrength  = TAL_CMOSPAD_DRV_2X /* Drive strength of CMOS pads when used as outputs (SDIO, SDO, GP_INTERRUPT, GPIO 1, GPIO 0) */
	},
	
    /* Rx settings */
    .rx = 
    {
        .rxProfile =
        {
            .rxFir = 
            {
                .gain_dB = -6,                /* filter gain */
#ifdef JESD204B_SPEED_4P9G
                .numFirCoefs = 72,            /* number of coefficients in the FIR filter */
#else
                .numFirCoefs = 48,            /* number of coefficients in the FIR filter */
#endif
                .coefs = &rxFirCoefs[0]
            },
            .rxFirDecimation = 2,            /* Rx FIR decimation (1,2,4) */
            .rxDec5Decimation = 4,            /* Decimation of Dec5 or Dec4 filter (5,4) */
#ifdef JESD204B_SPEED_4P9G
            .rhb1Decimation = 2,            /* RX Half band 1 decimation (1 or 2) */
            .rxOutputRate_kHz = 122880,            /* Rx IQ data rate in kHz */
            .rfBandwidth_Hz = 100000000,    /* The Rx RF passband bandwidth for the profile */
            .rxBbf3dBCorner_kHz = 100000,    /* Rx BBF 3dB corner in kHz */
#else
            .rhb1Decimation = 1,            /* RX Half band 1 decimation (1 or 2) */
            .rxOutputRate_kHz = 245760,            /* Rx IQ data rate in kHz */
            .rfBandwidth_Hz = 200000000,    /* The Rx RF passband bandwidth for the profile */
            .rxBbf3dBCorner_kHz = 200000,    /* Rx BBF 3dB corner in kHz */
#endif
            .rxDdcMode = TAL_RXDDC_BYPASS,   /* Rx DDC mode */
            .rxNcoShifterCfg =
            {
                .bandAInputBandWidth_kHz = 0,
                .bandAInputCenterFreq_kHz = 0,
                .bandANco1Freq_kHz = 0,
                .bandANco2Freq_kHz = 0,
                .bandBInputBandWidth_kHz = 0,
                .bandBInputCenterFreq_kHz = 0,
                .bandBNco1Freq_kHz = 0,
                .bandBNco2Freq_kHz = 0
            }
        },
        .framerSel = TAL_FRAMER_A,            /* Rx JESD204b framer configuration */
        .rxGainCtrl = 
        {
            .gainMode = TAL_MGC,            /* br3109rxGainMode_t gainMode */
            .rx1GainIndex = 195,            /* uint8_t rx1GainIndex */
            .rx2GainIndex = 195,            /* uint8_t rx2GainIndex */
            .rx1MaxGainIndex = 195,            /* uint8_t rx1MaxGainIndex */
            .rx1MinGainIndex = 132,            /* uint8_t rx1MinGainIndex */
            .rx2MaxGainIndex = 195,            /* uint8_t rx2MaxGainIndex */
            .rx2MinGainIndex = 132            /* uint8_t rx2MinGainIndex */
        },
        .rxChannels = TAL_RX1RX2,                /* The desired Rx Channels to enable during initialization */
    },


    /* Tx settings */
    .tx = 
    {
        .txProfile =
        {
            .dacDiv = 1,                        /* The divider used to generate the DAC clock */
            .txFir = 
            {
                .gain_dB = 6,                        /* filter gain */
#ifdef JESD204B_SPEED_4P9G
                .numFirCoefs = 40,                    /* number of coefficients in the FIR filter */
#else
                .numFirCoefs = 20,                    /* number of coefficients in the FIR filter */
#endif
                .coefs = &txFirCoefs[0]
            },
            .txFirInterpolation = 1,                    /* The Tx digital FIR filter interpolation (1,2,4) */
            .thb1Interpolation = 2,                    /* Tx Halfband1 filter interpolation (1,2) */
            .thb2Interpolation = 2,                    /* Tx Halfband2 filter interpolation (1,2)*/
#ifdef JESD204B_SPEED_4P9G
            .thb3Interpolation = 2,                    /* Tx Halfband3 filter interpolation (1,2)*/
            .txInt5Interpolation = 1,                    /* Tx Int5 filter interpolation (1,5) */
            .txInputRate_kHz = 245760,                    /* Primary Signal BW */
            .primarySigBandwidth_Hz = 100000000,    /* The Rx RF passband bandwidth for the profile */
            .rfBandwidth_Hz = 225000000,            /* The Tx RF passband bandwidth for the profile */
            .txBbf3dBCorner_kHz = 113000,                /* The BBF 3dB corner in kHz */
#else
            .thb3Interpolation = 1,                    /* Tx Halfband3 filter interpolation (1,2)*/
            .txInt5Interpolation = 1,                    /* Tx Int5 filter interpolation (1,5) */
            .txInputRate_kHz = 491520,                    /* Primary Signal BW */
            .primarySigBandwidth_Hz = 200000000,    /* The Rx RF passband bandwidth for the profile */
            .rfBandwidth_Hz = 450000000,            /* The Tx RF passband bandwidth for the profile */
            .txBbf3dBCorner_kHz = 225000,                /* The BBF 3dB corner in kHz */
#endif
        },
        .deframerSel = TAL_DEFRAMER_A,                    /* Br3109 JESD204b deframer config for the Tx data path */
        .txChannels = TAL_TX1TX2,                            /* The desired Tx channels to enable during initialization */
        .txAttenStepSize = TAL_TXATTEN_0P05_DB,            /* Tx Attenuation step size */
#ifdef JESD204B_SPEED_4P9G
        .tx1Atten_mdB = 10000,                            /* Initial Tx1 Attenuation */
        .tx2Atten_mdB = 10000,                            /* Initial Tx2 Attenuation */

#else
        .tx1Atten_mdB = 0,                            /* Initial Tx1 Attenuation */
        .tx2Atten_mdB = 0,                            /* Initial Tx2 Attenuation */
#endif
        .disTxDataIfPllUnlock = TAL_TXDIS_TX_RAMP_DOWN_TO_ZERO    /* Options to disable the transmit data when the RFPLL unlocks. */
    },


    /* ObsRx settings */
    .obsRx = 
    {
        .orxProfile =
        {
            .rxFir = 
            {
                .gain_dB = 6,                /* filter gain */
                .numFirCoefs = 24,            /* number of coefficients in the FIR filter */
                .coefs = &obsrxFirCoefs[0]
            },
            .rxFirDecimation = 1,            /* Rx FIR decimation (1,2,4) */
            .rxDec5Decimation = 4,            /* Decimation of Dec5 or Dec4 filter (5,4) */
#ifdef JESD204B_SPEED_4P9G
            .rhb1Decimation = 2,            /* RX Half band 1 decimation (1 or 2) */
            .orxOutputRate_kHz = 245760,            /* Rx IQ data rate in kHz */
            .rfBandwidth_Hz = 200000000,    /* The Rx RF passband bandwidth for the profile */
            .rxBbf3dBCorner_kHz = 225000,    /* Rx BBF 3dB corner in kHz */
            .orxDdcMode = TAL_ORXDDC_DISABLED,   /* ORx DDC mode */
#else
            .rhb1Decimation = 1,            /* RX Half band 1 decimation (1 or 2) */
            .orxOutputRate_kHz = 491520,            /* Rx IQ data rate in kHz */
            .rfBandwidth_Hz = 450000000,    /* The Rx RF passband bandwidth for the profile */
            .rxBbf3dBCorner_kHz = 225000,    /* Rx BBF 3dB corner in kHz */
            .orxDdcMode = TAL_ORXDDC_DISABLED,   /* ORx DDC mode */
#endif
        },
        .orxGainCtrl = 
        {
            .ORx1Atten_mdB = 0,
            .ORx2Atten_mdB = 0,
        },
        .framerSel = TAL_FRAMER_B,                /* ObsRx JESD204b framer configuration */
#ifdef EVB_SIG_UC1040_RRU 
        .obsRxChannelsEnable = TAL_ORXOFF,        /* The desired ObsRx Channels to disable during initialization */
#else
        .obsRxChannelsEnable = TAL_ORX1,        /* The desired ObsRx Channels to enable during initialization */
#endif
        .obsRxLoSource = TAL_OBSLO_RF_PLL                /* The ORx mixers can use the TX_PLL */
    },

    /* Digital Clock Settings */
    .clocks = 
    {
        .deviceClock_kHz = 122880,            /* CLKPLL and device reference clock frequency in kHz */
        .clkPllVcoFreq_kHz = 9830400,        /* CLKPLL VCO frequency in kHz */
        .clkPllHsDiv = TAL_HSDIV_2P5,            /* CLKPLL high speed clock divider */
        .rfPllUseExternalLo = 0,                /* 1= Use external LO for RF PLL, 0 = use internal LO generation for RF PLL */
        .rfPllPhaseSyncMode = TAL_RFPLLMCS_NOSYNC                /* RFPLL MCS (Phase sync) mode */
    },

    /* JESD204B settings */
    .jesd204Settings = 
    {
        /* Framer A settings */
        .framerA = 
        {
            .bankId = 1,                    /* JESD204B Configuration Bank ID -extension to Device ID (Valid 0..15) */
            .deviceId = 0,                    /* JESD204B Configuration Device ID - link identification number. (Valid 0..255) */
            .lane0Id = 0,                    /* JESD204B Configuration starting Lane ID.  If more than one lane used, each lane will increment from the Lane0 ID. (Valid 0..31) */
            .M = 4,                            /* number of ADCs (0, 2, or 4) - 2 ADCs per receive chain */
            .K = 32,                        /* number of frames in a multiframe (default=32), F*K must be a multiple of 4. (F=2*M/numberOfLanes) */
            .F = 4,                            /* F (number of bytes per frame) */
            .Np = 16,                            /* Np (converter sample resolution) */
            .scramble = 1,                    /* scrambling off if framerScramble= 0, if framerScramble>0 scramble is enabled. */
            .externalSysref = 1,            /* 0=use internal SYSREF, 1= use external SYSREF */
            .serializerLanesEnabled = 0x03,    /* serializerLanesEnabled - bit per lane, [0] = Lane0 enabled, [1] = Lane1 enabled */
            .serializerLaneCrossbar = 0xE4,    /* serializerLaneCrossbar */
            .lmfcOffset = 7,                /* lmfcOffset - LMFC offset value for deterministic latency setting */
            .newSysrefOnRelink = 0,            /* newSysrefOnRelink */
            .syncbInSelect = 0,                /* syncbInSelect; */
            .overSample = 0,                    /* 1=overSample, 0=bitRepeat */
            .syncbInLvdsMode = 1,
            .syncbInLvdsPnInvert = 0,
            .enableManualLaneXbar = 0 /* 0=auto, 1=manual */
        },
        /* Framer B settings */
        .framerB = 
        {
            .bankId = 0,                    /* JESD204B Configuration Bank ID -extension to Device ID (Valid 0..15) */
            .deviceId = 0,                    /* JESD204B Configuration Device ID - link identification number. (Valid 0..255) */
            .lane0Id = 0,                    /* JESD204B Configuration starting Lane ID.  If more than one lane used, each lane will increment from the Lane0 ID. (Valid 0..31) */
            .M = 2,                            /* number of ADCs (0, 2, or 4) - 2 ADCs per receive chain */
            .K = 32,                        /* number of frames in a multiframe (default=32), F*K must be a multiple of 4. (F=2*M/numberOfLanes) */
			.F = 4,                            /* F (number of bytes per frame) */
            .Np = 16,                            /* Np (converter sample resolution) */
            .scramble = 1,                    /* scrambling off if framerScramble= 0, if framerScramble>0 scramble is enabled. */
            .externalSysref = 1,            /* 0=use internal SYSREF, 1= use external SYSREF */
            .serializerLanesEnabled = 0x0C,    /* serializerLanesEnabled - bit per lane, [0] = Lane0 enabled, [1] = Lane1 enabled */
            .serializerLaneCrossbar = 0xE4,    /* serializerLaneCrossbar */
            .lmfcOffset = 7,                /* lmfcOffset - LMFC offset value for deterministic latency setting */
            .newSysrefOnRelink = 0,            /* newSysrefOnRelink */
            .syncbInSelect = 1,                /* syncbInSelect; */
            .overSample = 0,                    /* 1=overSample, 0=bitRepeat */
            .syncbInLvdsMode = 1,
            .syncbInLvdsPnInvert = 0,
            .enableManualLaneXbar = 0 /* 0=auto, 1=manual */
        },
        /* Deframer A settings */
        .deframerA = 
        {
            .bankId = 0,                    /* bankId extension to Device ID (Valid 0..15) */
            .deviceId = 0,                    /* deviceId  link identification number. (Valid 0..255) */
            .lane0Id = 0,                    /* lane0Id Lane0 ID. (Valid 0..31) */
            .M = 4,                            /* M  number of DACss (0, 2, or 4) - 2 DACs per transmit chain */
            .K = 32,                        /* K  #frames in a multiframe (default=32), F*K=multiple of 4. (F=2*M/numberOfLanes) */
            .scramble = 1,                    /* scramble  scrambling off if scramble= 0 */
            .externalSysref = 1,            /* externalSysref  0= use internal SYSREF, 1= external SYSREF */
            .deserializerLanesEnabled = 0x0F,    /* deserializerLanesEnabled  bit per lane, [0] = Lane0 enabled */
            .deserializerLaneCrossbar = 0xE4,    /* deserializerLaneCrossbar */
            .lmfcOffset = 7,                /* lmfcOffset	 LMFC offset value to adjust deterministic latency */
            .newSysrefOnRelink = 1,            /* newSysrefOnRelink */
            .syncbOutSelect = 0,                /* SYNCBOUT0/1 select */
            .Np = 16,                /* Np (converter sample resolution) */
            .syncbOutLvdsMode = 1,
            .syncbOutLvdsPnInvert = 0,
            .syncbOutCmosSlewRate = 0,
            .syncbOutCmosDriveLevel = 0,
            .enableManualLaneXbar = 0 /* 0=auto, 1=manual */
        },
        /* Deframer B settings */
        .deframerB = 
        {
            .bankId = 0,                    /* bankId extension to Device ID (Valid 0..15) */
            .deviceId = 0,                    /* deviceId  link identification number. (Valid 0..255) */
            .lane0Id = 0,                    /* lane0Id Lane0 ID. (Valid 0..31) */
            .M = 0,                            /* M  number of DACss (0, 2, or 4) - 2 DACs per transmit chain */
            .K = 32,                        /* K  #frames in a multiframe (default=32), F*K=multiple of 4. (F=2*M/numberOfLanes) */
            .scramble = 1,                    /* scramble  scrambling off if scramble= 0 */
            .externalSysref = 1,            /* externalSysref  0= use internal SYSREF, 1= external SYSREF */
            .deserializerLanesEnabled = 0x00,    /* deserializerLanesEnabled  bit per lane, [0] = Lane0 enabled */
            .deserializerLaneCrossbar = 0xE4,    /* deserializerLaneCrossbar */
            .lmfcOffset = 7,                /* lmfcOffset	 LMFC offset value to adjust deterministic latency */
            .newSysrefOnRelink = 0,            /* newSysrefOnRelink */
            .syncbOutSelect = 1,                /* SYNCBOUT0/1 select */
            .Np = 16,                /* Np (converter sample resolution) */
            .syncbOutLvdsMode = 1,
            .syncbOutLvdsPnInvert = 0,
            .syncbOutCmosSlewRate = 0,
            .syncbOutCmosDriveLevel = 0,
            .enableManualLaneXbar = 0 /* 0=auto, 1=manual */
        },
        .serAmplitude = 15,                    /* Serializer amplitude setting. Default = 15. Range is 0..15 */
        .serPreEmphasis = 1,                /* Serializer pre-emphasis setting. Default = 1 Range is 0..4 */
        .serInvertLanePolarity = 0,            /* Serializer Lane PN inversion select. Default = 0. Where, bit[0] = 1 will invert lane [0], bit[1] = 1 will invert lane 1, etc. */
        .desInvertLanePolarity = 0,            /* Deserializer Lane PN inversion select.  bit[0] = 1 Invert PN of Lane 0, bit[1] = Invert PN of Lane 1, etc */
        .desEqSetting = 1,                    /* Deserializer Equalizer setting. Applied to all deserializer lanes. Range is 0..4 */
        .sysrefLvdsMode = 1,                /* Use LVDS inputs on Br3109 for SYSREF */
        .sysrefLvdsPnInvert = 0              /*0= Do not PN invert SYSREF */
    }
};

//Only needs to be called if user wants to setup AGC parameters
br3109AgcCfg_t rxAgcCtrl =
{
    4,
    195,
    132,
    195,
    132,
    200, /*30720,*/  /* AGC gain update time in us (125us-250us - based on IQ data rate - set for 125us @ 245.76 Mhz) */
    10,
    10,
    16,
    0,
    1,
    0,
    0,
    0,
    1,
    31,
    246,
    4,
    1,          /*!<1- bit field to enable the multiple time constants in AGC loop for fast attack and fast recovery to max gain. */
    /* agcPower */
    {
        1,      /*!<1-bit field, enables the Rx power measurement block. */
        1,      /*!<1-bit field, allows using Rx PFIR for power measurement. */
        0,      /*!<1-bit field, allows to use the output of the second digital offset block in the Rx datapath for power measurement. */
        9,      /*!<AGC power measurement detect lower 0 threshold. Default = -12dBFS == 5, 7-bit register value where max = 0x7F, min = 0x00 */
        2,      /*!<AGC power measurement detect lower 1 threshold. Default = (offset) 4dB == 0, 4-bit register value where  max = 0xF, min = 0x00 */
        4,      /*!<AGC power measurement detect lower 0 recovery gain step. Default = 2dB - based on gain table step  size, 5-bit register value where max = 0x1F, min = 0x00 */
        4,      /*!<AGC power measurement detect lower 1 recovery gain step. Default = 4dB - based on gain table step size, 5-bit register value where max = 0x1F, min = 0x00 */
        5,      /*!< power measurement duration used by the decimated power block. Default = 0x05, 5-bit register value where max = 0x1F, min = 0x00 */
        5,      /*!<Allows power detection of data for a specific slice of the gain update counter. 16-bit register value (currently not used) */
        1,      /*!<Allows power detection of data for a specific slice of the gain update counter. 16-bit register value (currently not used) */
        5,      /*!<Allows power detection of data for a specific slice of the gain update counter. 16-bit register value (currently not used) */
        1,      /*!<Allows power detection of data for a specific slice of the gain update counter. 16-bit register value (currently not used) */
        2,      /*!<Default value should be 2*/
        0,
        0,
	0,	/*overRangeLowPowerGainStepAttack*/
	0	/*overRangeHighPowerGainStepAttack*/
    },
    /* agcPeak */
    {
        205,        /*!<1st update interval for the multiple time constant in AGC loop mode, Default:205. */
        2,          /*!<sets the 2nd update interval for the multiple time constant in AGC loop mode. Calculated as a multiple of  agcUnderRangeLowInterval  , Default: 4 */
        4,          /*!<sets the 3rd update interval for the multiple time constant in AGC loop mode. Calculated as a multiple of agcUnderRangeMidInterval and agcUnderRangeLowInterval, Default: 4 */
        39,/*25,*/ /*39,*/         /*!<AGC APD high threshold. Default=0x1F, 6-bit register value where max=0x3F, min =0x00 */
        49,         /*!<AGC APD peak detect high threshold. default = 0x1F, 6-bit register value where max = 0x3F, min = 0x00.  Set to 3dB below apdHighThresh */
        23,/*15,*/ /*23,*/         /*!<AGC APD peak detect low threshold. default = 3dB below high threshold, 6-bit register value where max =0x3F, min = 0x00 */
        19,         /*!<AGC APD peak detect low threshold. default = 3dB below high threshold, 6-bit register value where max = 0x3F, min = 0x00 . Set to 3dB below apdLowThresh  */
        6,          /*!<AGC APD peak detect upper threshold count. Default = 0x06 8-bit register value where max = 0xFF, min = 0x20  */
        3,          /*!<AGC APD peak detect lower threshold count. Default = 0x03, 8-bit register value where max = 0xFF, min = 0x00  */
        4,          /*!<AGC APD peak detect attack gain step. Default = 2dB step - based on gain table step size, 5-bit register  value, where max = 0x1F, min = 0x00  */
        2,          /*!<AGC APD gain index step size. Recommended to be same as hb2GainStepRecovery. Default = 0x00, 5-bit register value where max = 0x1F, min = 0x00  */
        1,          /*!<1-bit field, enables or disables the HB2 overload detector.  */
        1,          /*!<3-bit field. Sets the window of clock cycles (at the HB2 output rate) to meet the overload count. */
        1,          /*!<4-bit field. Sets the number of actual overloads required to trigger the overload signal.  */
        0x2000,        /*!<AGC decimator output high threshold. Default = 0xB5, 14-bit register value where max = 0x3FFF, min = 0x00 */
        0x05FF,         /*!<AGC decimator output low threshold. Default = 0x80, 14-bit register value where max = 0x3FFF, min = 0x00 */
        0x0BFF,         /*!<AGC decimator output low threshold. Default = 0x80, 14-bit register value where max = 0x3FFF, min = 0x00 */
        0x0FFF,        /*!<AGC decimator output low threshold. Default = 0x80, 14-bit register value where max = 0x3FFF, min = 0x00 */
        6,          /*!<AGC HB2 output upper threshold count. Default = 0x06, 8-bit register value where max = 0xFF, min =  0x20 */
        3,          /*!<AGC HB2 output lower threshold count. Default = 0x03, 8-bit register value where max = 0xFF, min = 0x00 */
        1,          /*!<AGC decimator gain index step size. Default = 0x00, 5-bit register value where max = 0x1F, min = 0x00 */
        4,          /*!<AGC HB2 gain index step size, when the HB2 Low Overrange interval 0 triggers a programmable number  of times. Default = 0x08, 5-bit register value where max = 0x1F, min = 0x00 */
        2,          /*!<AGC HB2 gain index step size, when the HB2 Low Overrange interval 1 triggers a programmable number of times. Default = 0x04, 5-bit register value where max = 0x1F, min = 0x00 */
        4,          /*!<AGC decimator output attack gain step. Default = 2dB step - based on gain table step size, 5-bit register value, where max = 0x1F, min = 0x00 */
        1,
        0,
        3,
        0,
        0
    }
};


